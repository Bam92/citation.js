<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Source: parse/bibtex/text.js - Docs - Citation.js</title>
    
    <meta name="theme-color" content="#FFC107">
    <link rel="shortcut icon" type="image/png" href="../favicon.png"/>
    <link rel="icon" type="image/png" href="../favicon.png"/>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="../static/css/api.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: parse/bibtex/text.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import TokenStack from '../../util/stack'

/**
 * Mapping of BibTeX Escaped Chars to Unicode.
 *
 * From [Zotero's reversed mapping table](https://github.com/zotero/translators/blob/master/BibTeX.js#L2353)
 * [REPO](https://github.com/zotero/translators)
 *
 * Accesed 11/09/2016
 *
 * @access private
 * @constant varBibTeXTokens
 * @default
 */
import varBibTeXTokens from './tokens.json'

/**
 * Match any BibTeX token.
 *
 *     new RegExp(
 *       // word commands
 *       '\\\\url|\\\\href|' +
 *       '{\\\\[a-zA-Z]+}|\\$\\\\[a-zA-Z]+\\$|' +
 *       // math
 *       '\\$[_^]{[0-9()+\\-=n]}\\$|'+
 *       // symbols
 *       '`{2,3}|\'{2,3}|-{2,3}|[!?]!|!\\?|{\\\\~}|' +
 *       // escaped symbols
 *       '\\\\[#$%&amp;~_^\\\\{}]|' +
 *       // diacritics
 *       '{\\\\(?:[a-z] |[`"\'^~=.])\\\\?[a-zA-Z]}|' +
 *       // non-breaking space
 *       '[\\s\\S]', 'g')
 *
 * @access private
 * @constant tokenPattern
 * @default
 */
const tokenPattern = /\\url|\\href|{\\[a-zA-Z]+}|\$\\[a-zA-Z]+\$|\$[_^]{[0-9()+=\-n]}\$|`{2,3}|'{2,3}|-{2,3}|[!?]!|!\?|{\\~}|\\[#$%&amp;~_^\\{}]|{\\(?:[a-z] |[`"'^~=.])\\?[a-zA-Z]}|[\s\S]/g

const whitespace = /^\s$/
const syntax = /^[@{}"=,\\]$/
const delimiters = {
  '"': '"',
  '{': '}',
  '': ''
}

/**
 * Tokenize a BibTeX string
 *
 * @access private
 * @method getTokenizedBibtex
 *
 * @param {String} str - Input BibTeX
 *
 * @return {String[]} list of tokens
 */
const getTokenizedBibtex = function (str) {
  // Substitute command of form "\X{X}" into "{\X X}"
  str = str
    .replace(/{?(\\[`"'^~=.]){?\\?([A-Za-z])}/g, '{$1$2}')
    .replace(/{?(\\[a-z]){?\\?([A-Za-z])}/g, '{$1 $2}')

  // Tokenize, with escaped characters in mind
  return str.match(tokenPattern)
}

/**
 * Format BibTeX data
 *
 * @access protected
 * @method parseBibTeX
 *
 * @param {String} str - The input data
 *
 * @return {CSL[]} The formatted input data
 */
const parseBibTeX = function (str) {
  const entries = []
  const tokens = getTokenizedBibtex(str)
  const stack = new TokenStack(tokens)

  try {
    stack.consume(whitespace)

    while (stack.tokensLeft()) {
      stack.consumeToken('@')
      stack.consume(whitespace)

      const type = stack.consume([whitespace, syntax], {inverse: true}).toLowerCase()

      stack.consume(whitespace)
      stack.consumeToken('{')
      stack.consume(whitespace)

      const label = stack.consume([whitespace, syntax], {inverse: true})

      stack.consume(whitespace)
      stack.consumeToken(',')
      stack.consume(whitespace)

      const properties = {}

      while (stack.tokensLeft()) {
        const key = stack.consume([whitespace, '='], {inverse: true}).toLowerCase()

        stack.consume(whitespace)
        stack.consumeToken('=')
        stack.consume(whitespace)

        const startDelimiter = stack.consume(/^({|"|)$/g)

        if (!delimiters.hasOwnProperty(startDelimiter)) {
          throw new SyntaxError(`Unexpected field delimiter at index ${stack.index}. Expected ` +
            `${Object.keys(delimiters).map(function (v) { return `"${v}"` }).join(', ')}; got "${startDelimiter}"`)
        }

        const endDelimiter = delimiters[startDelimiter]

        const tokenMap = token => {
          if (varBibTeXTokens.hasOwnProperty(token)) {
            return varBibTeXTokens[token]
          } else if (token.match(/^\\[#$%&amp;~_^\\{}]$/)) {
            return token.slice(1)
          } else if (token.length > 1) {
            throw new SyntaxError(`Escape sequence not recognized: ${token}`)
          } else {
            return token
          }
        }

        let openBrackets = 0
        const val = stack.consume((token, index) => {
          if (token === '{') {
            openBrackets++
          }

          if (stack.tokensLeft() &lt; endDelimiter.length) {
            throw new SyntaxError(`Unmatched delimiter at index ${stack.index}: Expected ${endDelimiter}`)
          } else if (!endDelimiter.length) {
            return ![whitespace, syntax].some(rgx => rgx.test(token))
          } else if (token === '}' &amp;&amp; openBrackets) {
            openBrackets--
            return true
          } else {
            token = stack.stack.slice(index, index + endDelimiter.length).join('')
            return token !== endDelimiter
          }
        }, {tokenMap})

        properties[key] = val

        stack.consumeN(endDelimiter.length)
        stack.consume(whitespace)

        // Last entry (no trailing comma)
        if (stack.matches('}')) { break }

        stack.consumeToken(',')
        stack.consume(whitespace)

        // Last entry (trailing comma)
        if (stack.matches('}')) { break }
      }

      stack.consumeToken('}')
      stack.consume(whitespace)

      entries.push({type, label, properties})
    }
  } catch (e) {
    console.error(`Uncaught SyntaxError: ${e.message}. Returning completed entries.`)

    // Remove last, possibly incomplete entry
    entries.pop()
  }

  return entries
}

export default parseBibTeX
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Cite.html">Cite</a></li><li><a href="CSL.html">CSL</a></li><li><a href="TokenStack.html">TokenStack</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addLocale">addLocale</a></li><li><a href="global.html#addTemplate">addTemplate</a></li><li><a href="global.html#async">async</a></li><li><a href="global.html#deepCopy">deepCopy</a></li><li><a href="global.html#fetchBibTeXType">fetchBibTeXType</a></li><li><a href="global.html#fetchCSLEngine">fetchCSLEngine</a></li><li><a href="global.html#fetchCSLItemCallback">fetchCSLItemCallback</a></li><li><a href="global.html#fetchCSLLocale">fetchCSLLocale</a></li><li><a href="global.html#fetchCSLStyle">fetchCSLStyle</a></li><li><a href="global.html#fetchDoiType">fetchDoiType</a></li><li><a href="global.html#fetchFile">fetchFile</a></li><li><a href="global.html#fetchFileAsync">fetchFileAsync</a></li><li><a href="global.html#fetchId">fetchId</a></li><li><a href="global.html#fetchWikidataType">fetchWikidataType</a></li><li><a href="global.html#getAttributedEntry">getAttributedEntry</a></li><li><a href="global.html#getBibTeX">getBibTeX</a></li><li><a href="global.html#getBibTeXJSON">getBibTeXJSON</a></li><li><a href="global.html#getBibTeXLabel">getBibTeXLabel</a></li><li><a href="global.html#getBibTxt">getBibTxt</a></li><li><a href="global.html#getDate">getDate</a></li><li><a href="global.html#getJSON">getJSON</a></li><li><a href="global.html#getLabel">getLabel</a></li><li><a href="global.html#getLocale">getLocale</a></li><li><a href="global.html#getName">getName</a></li><li><a href="global.html#getPrefixedEntry">getPrefixedEntry</a></li><li><a href="global.html#getTemplate">getTemplate</a></li><li><a href="global.html#hasLocale">hasLocale</a></li><li><a href="global.html#hasTemplate">hasTemplate</a></li><li><a href="global.html#htmlDict">htmlDict</a></li><li><a href="global.html#parseBibTeX">parseBibTeX</a></li><li><a href="global.html#parseBibTeXJSON">parseBibTeXJSON</a></li><li><a href="global.html#parseBibTeXProp">parseBibTeXProp</a></li><li><a href="global.html#parseBibTeXType">parseBibTeXType</a></li><li><a href="global.html#parseBibTxt">parseBibTxt</a></li><li><a href="global.html#parseBibTxtEntry">parseBibTxtEntry</a></li><li><a href="global.html#parseContentMine">parseContentMine</a></li><li><a href="global.html#parseCsl">parseCsl</a></li><li><a href="global.html#parseDate">parseDate</a></li><li><a href="global.html#parseDoi">parseDoi</a></li><li><a href="global.html#parseDoiApi">parseDoiApi</a></li><li><a href="global.html#parseDoiApiAsync">parseDoiApiAsync</a></li><li><a href="global.html#parseDoiJson">parseDoiJson</a></li><li><a href="global.html#parseInput">parseInput</a></li><li><a href="global.html#parseInputAsync">parseInputAsync</a></li><li><a href="global.html#parseInputChainLink">parseInputChainLink</a></li><li><a href="global.html#parseInputChainLinkAsync">parseInputChainLinkAsync</a></li><li><a href="global.html#parseInputData">parseInputData</a></li><li><a href="global.html#parseInputDataAsync">parseInputDataAsync</a></li><li><a href="global.html#parseInputType">parseInputType</a></li><li><a href="global.html#parseJSON">parseJSON</a></li><li><a href="global.html#parseName">parseName</a></li><li><a href="global.html#parseWikidata">parseWikidata</a></li><li><a href="global.html#parseWikidataJSON">parseWikidataJSON</a></li><li><a href="global.html#parseWikidataJSONAsync">parseWikidataJSONAsync</a></li><li><a href="global.html#parseWikidataProp">parseWikidataProp</a></li><li><a href="global.html#parseWikidataPropAsync">parseWikidataPropAsync</a></li><li><a href="global.html#textDict">textDict</a></li><li><a href="global.html#varRegex">varRegex</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.3</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>